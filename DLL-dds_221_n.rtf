{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1053{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset0 Times New Roman;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;\red255\green0\blue0;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\lang1053\f0\fs20 Bo Haglund, Bob Richardson\par
Rev N, 2012-07-16\par
Latest DLL issue with this description is available at {\field{\*\fldinst{HYPERLINK "http://www.bahnhof.se/wb758135/"}}{\fldrslt{\ul\cf1 http://www.bahnhof.se/wb758135/}}}\f0\fs20\par
\par
\par
\pard\keepn\nowidctlpar\s2\cf2\ul\b Short description of the DLL functions supported in Double Dummy Problem Solver 2.2.1\par
\pard\nowidctlpar\ulnone\b0\par
\pard\keepn\nowidctlpar\s3\b Callable functions\par
\pard\nowidctlpar\b0\par
extern "C" __declspec(dllimport) int __stdcall SolveBoard(struct deal, int target,  \par
    int solutions,  int mode, struct futureTricks *futp, int threadIndex);\par
\par
extern "C" __declspec(dllimport) int __stdcall SolveBoardPBN(struct dealPBN, int target,  \par
    int solutions,  int mode, struct futureTricks *futp, int threadIndex);\par
\par
extern "C" __declspec(dllimport) int __stdcall CalcDDtable(struct ddTableDeal tableDeal, \line     struct ddTableResults * tablep);\par
\par
extern "C" __declspec(dllimport) int __stdcall CalcDDtablePBN(struct ddTableDealPBN\line     tableDealPBN, struct ddTableResults * tablep);\par
\par
extern "C" __declspec(dllimport) int __stdcall SolveAllBoards(struct boardsPBN *bop,\par
    struct solvedBoards *solvedp);             \par
\par
\par
\pard\keepn\nowidctlpar\s3\b SolveBoard\par
\pard\nowidctlpar\b0\par
SolveBoard is thread-safe, so several threads (max 8) can call SolveBoard in parallel.\par
\par
Before SolveBoard can be called, a structure of type "futureTricks" must be declared. \par
\par
\b SolveBoard\b0  returns a status integer, "no fault" means the DLL supplies the trick data in the "futureTricks" type structure.\line Status codes:   \par
   1=No fault, \par
  -1=Unknown fault, \par
  -2=No of cards = 0, \par
  -3=target > Number of tricks left,                         \par
  -4=Duplicated cards, \par
  -5=target < -1, \par
  -7=target >13, \par
  -8=solutions < 1, \par
  -9=solutions > 3, \par
-10=No of cards > 52\par
-11=Not used\par
-12=Suit or rank value out of range for deal.currentTrickSuit or deal.currentTrickRank.\par
-13=Card already played in the current trick is also defined as a remaining card to play.\par
-14=Wrong number of remaining cards for a hand.\par
-15=threadIndex < 0 or > 7.\line   \line Structure \rdblquote\b deal\b0\rdblquote  defines all data needed to describe the deal to be analyzed.\par
struct deal \{\f1  \par
\f0    int trump;   /* I.e. which suit that is trump or if contract is NT, Spades=0, Hearts=1, Diamonds=2, Clubs=3,  NT=4 */\f1  \par
\f0    int first;      /* 0-3, 0=North, 1=East, 2=South, 3=West , Leading hand for the trick.*/\f1  \par
    \f0 int currentTrickSuit[3];  /* 0-2 for up to 3 cards in the order played */\par
   int currentTrickRank[3];  /* 2-14 for up to 3 cards */\f1\par
\f0    unsigned int remainCards[4][4]; /* 1\super st\nosupersub  index hand (0-3), 2\super nd\nosupersub  index suit (0-3), values as bitstring of ranks bit 0=0, bit 1=0, bit 2=rank 2, \'85\'85\'85. bit 14=rank 14, bit 15=0\f1  \f0 for cards remaining after already played cards (cards already played to the current trick are not included in this bitstring).  \line  The decimal value for a card then range between 4 (=rank 2) and 16384  (Ace=rank 14). */\f1  \par
\f0\};\f1  \f0\par
\par
Parameter \rdblquote\b target\b0\rdblquote  is the number of tricks to be won by the side to play, -1 means that the program\f1  \f0 shall find the maximum number. For equivalent  cards only the highest is returned. \par
\line Parameter \rdblquote\b solutions\b0\rdblquote  defines how many card solutions that SolveBoard must return:\par
  target=1-13, solutions=1:  Returns only one of the cards. Its returned score is the same as target whentarget or higher tricks can be won. Otherwise, score \endash 1 is returned if target cannot be reached, or score 0 if no tricks can be won. \line   target=-1, solutions=1:  Returns only one of the optimum cards and its score.\par
  \cf0 target=0, solutions=1:  Returns only one of the cards legal to play with score set to 0.\cf2\line   target 1-13, solutions=2:  Return all cards meeting target. Their returned scores are the same as target when target or higher tricks can be won. Otherwise, only one card is returned with score \endash 1 if target cannot be reached, or score 0 for all cards legal to play if no tricks can be won.\line   target \endash 1, solutions=2:  Return all optimum cards with their scores.\par
  \cf0 target=0, solutions=2:  Return all cards legal to play with scores set to 0\cf3 .\cf2\line   target irrelevant, solutions=3:  Return all cards that can be legally played with their scores in descending  order.\par
\par
Parameter \rdblquote\b mode\b0\rdblquote  defines the DLL mode of operation.\line   mode=0:  Do not search to find the score if the hand to play has only one card, including its equivalents, to play. Score is set to \endash 2 for this card, indicating that there are no alternative cards. If there are multiple choices for cards to play, search is done to find the score. This mode is very fast but you don\rquote t \par
  mode=1:  Always \cf0\lang1033 search to find the score. Even when the hand to play has only one card,  with possible equivalents, to play.  For both mode=0 and mode=1: If the preceding SolveBoard call had the same trump suit and the same deal, except for deal.first, then the transposition table contents is reused from the preceding SolveBoard call. Setting mode=2 is no longer needed in this case, but can still be done for backwards compatibility.\line   mode=2:  As for mode=1, but the transposition table contents is reused from the preceding SolveBoard call. It is the responsibility of the programmer using the DLL to ensure that reusing the table is safe in the actual situation. Example: Deal is the same, except for deal.first. Trump suit is the same. \par
\pard\nowidctlpar\fi720 1\super st\nosupersub  call:  SolveBoard(deal, -1, 1, 1, &fut, 0),  deal.first=1, i.e. East leads.\par
\pard\nowidctlpar  \tab 2\super nd\nosupersub  call:  SolveBoard(deal, -1, 1, 2, &fut, 0),  deal.first=2, i.e. South leads.\par
 \tab 3rd call:  SolveBoard(deal, -1, 1, 2, &fut, 0),  deal.first=3, i.e. West leads. \par
\pard\nowidctlpar\fi720 4th call:  SolveBoard(deal, -1, 1, 2, &fut, 0),  deal.first=0, i.e. North leads.   \cf2\lang1053\par
\pard\nowidctlpar\par
struct \b futureTricks\b0  \{ /* The DLL provides the score (number of tricks) that can be won by the card to play defined by its suit and rank. Array of all alternative cards. */\f1  \par
\f0   int nodes;     /* Number of searched nodes */\par
  int cards;         /*  No of alternative cards  */\f1\par
\f0   int suit[13];         /* 0=Spades, 1=Hearts, 2=Diamonds, 3=Clubs */\par
  int rank[13];        /* 2-14 for 2 through Ace *\b / \par
  \b0 int equals[13];        /* Bitstring of ranks for equivalent lower rank cards. The decimal value range between 4 (=2) and 8192 (King=rank 13).  When there are several \rdblquote equals\rdblquote , the value is the sum of each \rdblquote equal\rdblquote . *\b /\b0\par
  int score[13];     /* -1 indicates that target was not reached, otherwise target or max numbe of tricks */\f1  \par
\f0\} ; \par
\par
Parameter \rdblquote\b threadIndex\b0\rdblquote  defines the identity of the thread used when calling SolveBoard.\par
Maximum 8 threads can call SolveBoard in parallel, threadIndex must be an integer of the range 0..7.\par
\cf0\lang1033\fs24\par
\pard\keepn\nowidctlpar\s3\cf2\lang1053\b\fs20\par
SolveBoardPBN\par
\par
\b0 In SolveBoardPBN the remaining cards in the deal information are given in PBN text\par
format (e.g. \line W:T5.K4.652.A98542 K6.QJT976.QT7.Q6 432.A.AKJ93.JT73 AQJ987.8532.84.K) instead of using bits 2-14 in an integer array. Otherwise, SolveboardPBN is identical to SolveBoard.\par
\par
struct dealPBN \{\par
   int trump; \par
   int first; \par
   int currentTrickSuit[3];  \b\par
   \b0 int currentTrickRank[3];  \par
   char remainCards[80];   /* First character identifies the hand having the cards given first\par
                                         in the string, then the cards of the other hands are given in a\par
\tab\tab\tab      clock-wise order, see example above. Null characters fill out\par
\tab\tab\tab      the character array at the end. */ \par
\};\par
\b\par
\par
CalcDDtable\par
\pard\nowidctlpar\b0\f1\par
\pard\keepn\nowidctlpar\s1\f0 CalcDDtable calculates the double dummy values of the initial 52 cards for all the 20 trump suit/declarer hand combinations.   \par
\pard\nowidctlpar\cf0\lang1033\fs24\par
\pard\keepn\nowidctlpar\s1\cf2\lang1053\fs20 Before CalcDDtable can be called, a structure of type " ddTableResults" must be declared.\par
\pard\nowidctlpar\b CalcDDtable\b0  returns a status integer, "no fault" means the DLL supplies the double dummy scores in the "ddTableResults" type structure.\line Status codes:   \par
   1=No fault,\par
   Other status codes are errors, with codes equal to SolveBoard status codes.   \cf0\lang1033\fs24\par
\par
\cf2\lang1053\fs20 Structure \rdblquote\b ddTableDeal\b0\rdblquote  defines the dealt cards to be analyzed.\cf0\lang1033\par
struct ddTableDeal \{\par
  unsigned int cards[4][4];   /* 1\super st\nosupersub  index is hand, 2\super nd\nosupersub  index is suit, same coding as for deal.remainCards for SolveBoard. */\par
\};\par
\par
\cf2\lang1053 struct \b ddTableResults\b0  \{ /* For each combination trump suit / declarer hand, the DLL provides the double dummy score. */\cf0\lang1033\par
  int resTable[5][4];\tab /* 1\super st\nosupersub  index is trump (0=Spades, 1=Hearts, 2=Diamonds, 3=Clubs, 4=No Trump 2\super nd\nosupersub  index is declarer hand, 0=North, 1=East, 2=South, 3=West */\par
\};\par
\fs24\par
\par
\cf2\lang1053\b\fs20 CalcDDtablePBN\cf0\lang1033\b0\fs24\par
\par
\pard\keepn\nowidctlpar\s3\cf2\lang1053\fs20 In CalcDDtablePBN the remaining cards in the deal information are given in PBN text format, see the description above for SolveBoardPBN. Otherwise, CalcDDtablePBN is identical to CalcDDtable.\par
\pard\nowidctlpar\par
struct ddTableDealPBN \{\par
  char cards[80];\par
\};\par
\par
\par
\b SolveAllBoards\b0\par
\par
SolveAllBoards is called with a buffer containing a number of boards, maximum 100 boards per call. Each board is defined with the same input data as in SolveBoardPBN. The input data per board can be freely given independent of the settings for the other deals. SolveAllBoards uses multi-thread calls to SolveBoardPBN for solving the buffered boards.\par
\par
struct boardsPBN \{\par
  int noOfBoards;\par
  struct dealPBN deals[MAXNOOFBOARDS];\par
  int target[MAXNOOFBOARDS];\par
  int solutions[MAXNOOFBOARDS];\par
  int mode[MAXNOOFBOARDS];\par
\};\par
\par
struct solvedBoards \{\par
  int noOfBoards;\par
  struct futureTricks solvedBoard[MAXNOOFBOARDS];\par
\};\par
\par
In the SolveAllBoards call, the cards are coded in PBN text format using the dealPBN structure. The number of boards to be solved must be defined in the boardsPBN structure, the number must not exceed MAXNOOFBOARDS which is 100. In the returned information in struct solvedBoards, the number of solved boards are given. The futureTricks information is provided for all solved boards with the same returned information per board as with SolveBoard. \par
\par
SolveAllBoards returns 1 if the call succeeds, otherwise an error code identical to the SolveBoard error codes is given when there is a problem in the input information.\par
\par
\b Note\b0\par
\par
SolveAllBoards is optimal when the input boards are dissimilar. Adjacent boards in the boards buffer that are similar (same trump, very minor difference between cards distribution between hands) typically means that transposition table information cannot be reused. That is because these boards typically use different threads. For this reason, the SolveAllBoards function should not be used as an alternative to the CalcDDtable function. \par
\cf0\lang1033\fs24\par
\par
\pard\keepn\nowidctlpar\s1\cf2\lang1053\b\fs20 Revision History\par
\pard\nowidctlpar\b0\par
Rev A, 2006-02-25.\tab\tab First issue.\par
\par
Rev B, 2006-03-20\tab\tab Updated issue.\par
\par
\pard\nowidctlpar\fi-2880\li2880 Rev C, 2006-03-28\tab Updated issue. Addition of the SolveBoard parameter \rdblquote mode\rdblquote .\par
\par
Rev D, 2006-04-05\tab Updated issue. Usage of target=0 to list all cards that are legal to play.\par
\par
Rev E, 2006-05-29\tab Updated issue. New error code \endash 10 for number of cards > 52.\par
\par
Rev F, 2006-08-09\tab Updated issue. New mode parameter value = 2. New error code \endash 11 for calling SolveBoard with mode = 2 and forbidden values of other parameters.\par
\pard\nowidctlpar\par
\pard\nowidctlpar\fi-2880\li2880 Rev F1, 2006-08-14\tab Clarifications on conditions for returning scores for the different combinations of the values for target and solutions.\par
\par
Rev F2, 2006-08-26\tab New error code \endash 12 for wrongly set values of deal.currentTrickSuit and\line deal.currentTrickRank.\par
\par
Rev G, 2007-01-04\tab New DDS release 1.1, otherwise no change compared to isse F2.\par
\par
Rev H, 2007-04-23\tab DDS release 1.4, changes for parameter mode=2.\par
\par
Rev I,  2010-04-10\tab DDS release 2.0, multi-thread support.\par
\par
Rev J, 2010-05-29\tab DDS release 2.1, OpenMP support, reuse of previous DD transposition table results of similar deals.\par
\par
Rev K, 2010-10-27\tab Correction of fault in the description:  2nd index in resTable of the structure ddTableResults is declarer hand.\par
\par
Rev L, 2011-10-14\tab Added SolveBoardPBN and CalcDDtablePBN.\par
\par
Rev M, 2012-07-06\tab Added SolveAllBoards. \par
\par
Rev N, 2012-07-16\tab Max number of threads is 8. \par
\par
 \par
\par
}
 